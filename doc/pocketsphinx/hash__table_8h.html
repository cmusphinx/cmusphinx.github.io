<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PocketSphinx: sphinxbase/hash_table.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PocketSphinx
   &#160;<span id="projectnumber">5.0.0rc3</span>
   </div>
   <div id="projectbrief">A small speech recognizer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_da7289121d0013e03540a8198af12b2c.html">sphinxbase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hash_table.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash table implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sphinxbase/sphinxbase_export.h&gt;</code><br />
<code>#include &lt;<a class="el" href="prim__type_8h_source.html">sphinxbase/prim_type.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="glist_8h_source.html">sphinxbase/glist.h</a>&gt;</code><br />
</div>
<p><a href="hash__table_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__entry__s.html">hash_entry_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__table__s.html">hash_table_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__iter__s.html">hash_iter_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac98525ff8ec582358783aecbd388842d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ac98525ff8ec582358783aecbd388842d">hash_entry_val</a>(e)&#160;&#160;&#160;((e)-&gt;val)</td></tr>
<tr class="separator:ac98525ff8ec582358783aecbd388842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff378b212469b2ec6dde13b6f0934b"><td class="memItemLeft" align="right" valign="top"><a id="aa9ff378b212469b2ec6dde13b6f0934b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_entry_key</b>(e)&#160;&#160;&#160;((e)-&gt;key)</td></tr>
<tr class="separator:aa9ff378b212469b2ec6dde13b6f0934b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d92dd662edb83d572dc2fef278816"><td class="memItemLeft" align="right" valign="top"><a id="a4c0d92dd662edb83d572dc2fef278816"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_entry_len</b>(e)&#160;&#160;&#160;((e)-&gt;len)</td></tr>
<tr class="separator:a4c0d92dd662edb83d572dc2fef278816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47264dff359c0a0d4c144e54d0819ce9"><td class="memItemLeft" align="right" valign="top"><a id="a47264dff359c0a0d4c144e54d0819ce9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_inuse</b>(h)&#160;&#160;&#160;((h)-&gt;inuse)</td></tr>
<tr class="separator:a47264dff359c0a0d4c144e54d0819ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d9d0efddc207e3d7be3c417dcd7128"><td class="memItemLeft" align="right" valign="top"><a id="aa0d9d0efddc207e3d7be3c417dcd7128"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_size</b>(h)&#160;&#160;&#160;((h)-&gt;size)</td></tr>
<tr class="separator:aa0d9d0efddc207e3d7be3c417dcd7128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbbcfa2a2d360c2a8960b960ae34a3"><td class="memItemLeft" align="right" valign="top"><a id="a30fbbcfa2a2d360c2a8960b960ae34a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_YES</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a30fbbcfa2a2d360c2a8960b960ae34a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1a9795611575f717b08d2bad5d6f83"><td class="memItemLeft" align="right" valign="top"><a id="aec1a9795611575f717b08d2bad5d6f83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_NO</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aec1a9795611575f717b08d2bad5d6f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393c56322e54607a48e6bc61169d92bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a393c56322e54607a48e6bc61169d92bf">hash_table_enter_int32</a>(h,  k,  v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a>((h),(k),(void *)(long)(v)))</td></tr>
<tr class="separator:a393c56322e54607a48e6bc61169d92bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4286033aa772a9d1f3aa219469324f5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a4286033aa772a9d1f3aa219469324f5b">hash_table_replace_int32</a>(h,  k,  v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a>((h),(k),(void *)(long)(v)))</td></tr>
<tr class="separator:a4286033aa772a9d1f3aa219469324f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada31c1e0bcf359a7ca934748f4680333"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ada31c1e0bcf359a7ca934748f4680333">hash_table_enter_bkey_int32</a>(h,  k,  l,  v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a>((h),(k),(l),(void *)(long)(v)))</td></tr>
<tr class="separator:ada31c1e0bcf359a7ca934748f4680333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace238b264acacb8e6cb0de14f1035f53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ace238b264acacb8e6cb0de14f1035f53">hash_table_replace_bkey_int32</a>(h,  k,  l,  v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a>((h),(k),(l),(void *)(long)(v)))</td></tr>
<tr class="separator:ace238b264acacb8e6cb0de14f1035f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a033b5e27dc8c6612a8ca7f66e7e2f1a9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a033b5e27dc8c6612a8ca7f66e7e2f1a9">hash_entry_t</a></td></tr>
<tr class="separator:a033b5e27dc8c6612a8ca7f66e7e2f1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5b8cc5fa97c5c57b30eb70c81c8204"><td class="memItemLeft" align="right" valign="top"><a id="a4b5b8cc5fa97c5c57b30eb70c81c8204"></a>
typedef struct <a class="el" href="structhash__table__s.html">hash_table_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_t</b></td></tr>
<tr class="separator:a4b5b8cc5fa97c5c57b30eb70c81c8204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7a283c82d5003d7f01741f2b63dcc1"><td class="memItemLeft" align="right" valign="top"><a id="a2a7a283c82d5003d7f01741f2b63dcc1"></a>
typedef struct <a class="el" href="structhash__iter__s.html">hash_iter_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hash_iter_t</b></td></tr>
<tr class="separator:a2a7a283c82d5003d7f01741f2b63dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a56d93e8c03e066b77377ac6eab50cfae"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a56d93e8c03e066b77377ac6eab50cfae">hash_table_new</a> (int32 size, int32 casearg)</td></tr>
<tr class="separator:a56d93e8c03e066b77377ac6eab50cfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a588c22946f8cc16328973035ed19e3"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a0a588c22946f8cc16328973035ed19e3">hash_table_free</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h)</td></tr>
<tr class="separator:a0a588c22946f8cc16328973035ed19e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfe63c3869c271b125a8413ee384412"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, void *val)</td></tr>
<tr class="separator:aebfe63c3869c271b125a8413ee384412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b28ea189a98ef8f2a3c5521482968"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, void *val)</td></tr>
<tr class="separator:ae61b28ea189a98ef8f2a3c5521482968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d87b1b825c302473f2d7c5a3b88475"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#af1d87b1b825c302473f2d7c5a3b88475">hash_table_delete</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key)</td></tr>
<tr class="separator:af1d87b1b825c302473f2d7c5a3b88475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ab1f5eb2f1b4689645d1e1c19dc887"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aa2ab1f5eb2f1b4689645d1e1c19dc887">hash_table_delete_bkey</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, size_t len)</td></tr>
<tr class="separator:aa2ab1f5eb2f1b4689645d1e1c19dc887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab374d21e25009d397642e3465308c7"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acab374d21e25009d397642e3465308c7">hash_table_empty</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h)</td></tr>
<tr class="separator:acab374d21e25009d397642e3465308c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5752fadefe2662adb2c141f1511062"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, size_t len, void *val)</td></tr>
<tr class="separator:a6f5752fadefe2662adb2c141f1511062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273237d63833e5625c830f421d9463de"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, size_t len, void *val)</td></tr>
<tr class="separator:a273237d63833e5625c830f421d9463de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e5ed410eb96f514b00fdce770fbd7"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a9a1e5ed410eb96f514b00fdce770fbd7">hash_table_lookup</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, void **val)</td></tr>
<tr class="separator:a9a1e5ed410eb96f514b00fdce770fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf27e8e7e336faf6653649937c42ed8"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acaf27e8e7e336faf6653649937c42ed8">hash_table_lookup_int32</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, int32 *val)</td></tr>
<tr class="separator:acaf27e8e7e336faf6653649937c42ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5b3924c0e3a50f94c86bb5fd078e8"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a91f5b3924c0e3a50f94c86bb5fd078e8">hash_table_lookup_bkey</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, size_t len, void **val)</td></tr>
<tr class="separator:a91f5b3924c0e3a50f94c86bb5fd078e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc530eda0b105745cf3a47cc3c1148e4"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acc530eda0b105745cf3a47cc3c1148e4">hash_table_lookup_bkey_int32</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, const char *key, size_t len, int32 *val)</td></tr>
<tr class="separator:acc530eda0b105745cf3a47cc3c1148e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6e6373d3c371d57861a9a875edb207"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aae6e6373d3c371d57861a9a875edb207">hash_table_iter</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h)</td></tr>
<tr class="separator:aae6e6373d3c371d57861a9a875edb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad023321efab26a30bd6d855fbdbe08a3"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ad023321efab26a30bd6d855fbdbe08a3">hash_table_iter_next</a> (<a class="el" href="structhash__iter__s.html">hash_iter_t</a> *itor)</td></tr>
<tr class="separator:ad023321efab26a30bd6d855fbdbe08a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa43b228d7dc24f5221d281debeb025"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a7aa43b228d7dc24f5221d281debeb025">hash_table_iter_free</a> (<a class="el" href="structhash__iter__s.html">hash_iter_t</a> *itor)</td></tr>
<tr class="separator:a7aa43b228d7dc24f5221d281debeb025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f59389f05d8871003da4692a9c2acc"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a61f59389f05d8871003da4692a9c2acc">hash_table_tolist</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, int32 *count)</td></tr>
<tr class="separator:a61f59389f05d8871003da4692a9c2acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2721f6b601c80ceeeae570589fd12e38"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a2721f6b601c80ceeeae570589fd12e38">hash_table_display</a> (<a class="el" href="structhash__table__s.html">hash_table_t</a> *h, int32 showkey)</td></tr>
<tr class="separator:a2721f6b601c80ceeeae570589fd12e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hash table implementation. </p>
<p>This hash tables are intended for associating a pointer/integer "value" with a char string "key", (e.g., an ID with a word string). Subsequently, one can retrieve the value by providing the string key. (The reverse functionality&ndash;obtaining the string given the value&ndash;is not provided with the hash table module.) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac98525ff8ec582358783aecbd388842d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98525ff8ec582358783aecbd388842d">&#9670;&nbsp;</a></span>hash_entry_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_entry_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access macros </p>

</div>
</div>
<a id="ada31c1e0bcf359a7ca934748f4680333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada31c1e0bcf359a7ca934748f4680333">&#9670;&nbsp;</a></span>hash_table_enter_bkey_int32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_bkey_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a>((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a 32-bit integer value in a hash table.</p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

</div>
</div>
<a id="a393c56322e54607a48e6bc61169d92bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393c56322e54607a48e6bc61169d92bf">&#9670;&nbsp;</a></span>hash_table_enter_int32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a>((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a 32-bit integer value to a hash table.</p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

</div>
</div>
<a id="ace238b264acacb8e6cb0de14f1035f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace238b264acacb8e6cb0de14f1035f53">&#9670;&nbsp;</a></span>hash_table_replace_bkey_int32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_bkey_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a>((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a 32-bit integer value in a hash table.</p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

</div>
</div>
<a id="a4286033aa772a9d1f3aa219469324f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4286033aa772a9d1f3aa219469324f5b">&#9670;&nbsp;</a></span>hash_table_replace_int32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a>((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a 32-bit integer value in a hash table.</p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a033b5e27dc8c6612a8ca7f66e7e2f1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033b5e27dc8c6612a8ca7f66e7e2f1a9">&#9670;&nbsp;</a></span>hash_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a> <a class="el" href="hash__table_8h.html#a033b5e27dc8c6612a8ca7f66e7e2f1a9">hash_entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing. There are definitely better ways to do internal hashing (i.e. when everything is stored in the memory.) In Sphinx 3, this is a reasonable practice because hash table is only used in lookup in initialization or in lookups which is not critical for speed. Another note by ARCHAN at 20050703: To use this data structure properly, it is very important to realize that the users are required to handle memory allocation of the C-style keys. The hash table will not make a copy of the memory allocated for any of the C-style key. It will not allocate memory for it. It will not delete memory for it. As a result, the following code sniplet will cause memory leak. <br  />
</p>
<p>while (1){ str=(char*)<a class="el" href="ckd__alloc_8h.html#aa00ef21903bc4f8a972488417adc8d2e">ckd_calloc(str_length,sizeof(char*))</a> if(hash_enter(ht,str,id)!=id){ printf("fail to add key str %s with val id %d\n",str,id)} } A note by dhuggins on 20061010: Changed this to use void * instead of int32 as the value type, so that arbitrary objects can be inserted into a hash table (in a way that won't crash on 64-bit machines ;) The hash table structures. Each hash table is identified by a hash_table_t structure. hash_table_t.table is pre-allocated for a user-controlled max size, and is initially empty. As new entries are created (using hash_enter()), the empty entries get filled. If multiple keys hash to the same entry, new entries are allocated and linked together in a linear list. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af1d87b1b825c302473f2d7c5a3b88475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d87b1b825c302473f2d7c5a3b88475">&#9670;&nbsp;</a></span>hash_table_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete an entry with given key and associated value to hash table h. Return the value associated with the key (NULL if it did not exist) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which a key will be deleted </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2ab1f5eb2f1b4689645d1e1c19dc887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ab1f5eb2f1b4689645d1e1c19dc887">&#9670;&nbsp;</a></span>hash_table_delete_bkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like hash_table_delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which a key will be deleted </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2721f6b601c80ceeeae570589fd12e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2721f6b601c80ceeeae570589fd12e38">&#9670;&nbsp;</a></span>hash_table_display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_display </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>showkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display a hash-with-chaining representation on the screen. Currently, it will only works for situation where hash_enter was used to enter the keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Hash table to display </td></tr>
    <tr><td class="paramname">showkey</td><td>In: Show the string or not, Use 0 if hash_enter_bkey was used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acab374d21e25009d397642e3465308c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab374d21e25009d397642e3465308c7">&#9670;&nbsp;</a></span>hash_table_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete all entries from a hash_table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebfe63c3869c271b125a8413ee384412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfe63c3869c271b125a8413ee384412">&#9670;&nbsp;</a></span>hash_table_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to add a new entry with given key and associated value to hash table h. If key doesn't already exist in hash table, the addition is successful, and the return value is val. But if key already exists, return its existing associated value. (The hash table is unchanged; it is up to the caller to resolve the conflict.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f5752fadefe2662adb2c141f1511062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5752fadefe2662adb2c141f1511062">&#9670;&nbsp;</a></span>hash_table_enter_bkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like hash_table_enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a588c22946f8cc16328973035ed19e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a588c22946f8cc16328973035ed19e3">&#9670;&nbsp;</a></span>hash_table_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae6e6373d3c371d57861a9a875edb207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6e6373d3c371d57861a9a875edb207">&#9670;&nbsp;</a></span>hash_table_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a>* hash_table_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start iterating over key-value pairs in a hash table. </p>

</div>
</div>
<a id="a7aa43b228d7dc24f5221d281debeb025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa43b228d7dc24f5221d281debeb025">&#9670;&nbsp;</a></span>hash_table_iter_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_iter_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td>
          <td class="paramname"><em>itor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete an unfinished iterator. </p>

</div>
</div>
<a id="ad023321efab26a30bd6d855fbdbe08a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad023321efab26a30bd6d855fbdbe08a3">&#9670;&nbsp;</a></span>hash_table_iter_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a>* hash_table_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td>
          <td class="paramname"><em>itor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next key-value pair in iteration.</p>
<p>This function automatically frees the iterator object upon reaching the final entry.</p>
<dl class="section return"><dt>Returns</dt><dd>the next entry in the hash table, or NULL if done. </dd></dl>

</div>
</div>
<a id="a9a1e5ed410eb96f514b00fdce770fbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1e5ed410eb96f514b00fdce770fbd7">&#9670;&nbsp;</a></span>hash_table_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up a key in a hash table and optionally return the associated value. </p><dl class="section return"><dt>Returns</dt><dd>0 if key found in hash table, else -1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated string whose value is sought </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91f5b3924c0e3a50f94c86bb5fd078e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f5b3924c0e3a50f94c86bb5fd078e8">&#9670;&nbsp;</a></span>hash_table_lookup_bkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc530eda0b105745cf3a47cc3c1148e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc530eda0b105745cf3a47cc3c1148e4">&#9670;&nbsp;</a></span>hash_table_lookup_bkey_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up a 32-bit integer value in a hash table.</p>
<p>This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf27e8e7e336faf6653649937c42ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf27e8e7e336faf6653649937c42ed8">&#9670;&nbsp;</a></span>hash_table_lookup_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up a 32-bit integer value in a hash table.</p>
<p>This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated string whose value is sought </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d93e8c03e066b77377ac6eab50cfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d93e8c03e066b77377ac6eab50cfae">&#9670;&nbsp;</a></span>hash_table_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structhash__table__s.html">hash_table_t</a>* hash_table_new </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>casearg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new hash table for a given expected size.</p>
<dl class="section note"><dt>Note</dt><dd>Case sensitivity of hash keys applies to 7-bit ASCII characters only, and is not locale-dependent.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>handle to allocated hash table. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>In: Expected number of entries in the table </td></tr>
    <tr><td class="paramname">casearg</td><td>In: Whether case insensitive for key comparisons. When 1, case is insentitive, 0, case is sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61b28ea189a98ef8f2a3c5521482968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61b28ea189a98ef8f2a3c5521482968">&#9670;&nbsp;</a></span>hash_table_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new entry with given key and value to hash table h. If the key already exists, its value is replaced with the given value, and the previous value is returned, otherwise val is returned.</p>
<p>A very important but subtle point: The key pointer in the hash table is <b>replaced</b> with the pointer passed to this function. In general you should always pass a pointer to <a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter()</a> whose lifetime matches or exceeds that of the hash table. In some rare cases it is convenient to initially enter a value with a short-lived key, then later replace that with a long-lived one. This behaviour allows this to happen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a273237d63833e5625c830f421d9463de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273237d63833e5625c830f421d9463de">&#9670;&nbsp;</a></span>hash_table_replace_bkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like hash_table_replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61f59389f05d8871003da4692a9c2acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f59389f05d8871003da4692a9c2acc">&#9670;&nbsp;</a></span>hash_table_tolist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a> hash_table_tolist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__s.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a glist of valid hash_entry_t pointers from the given hash table. Return the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Hash table from which list is to be generated </td></tr>
    <tr><td class="paramname">count</td><td>Out: Number of entries in the list. If this is NULL, no count will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
